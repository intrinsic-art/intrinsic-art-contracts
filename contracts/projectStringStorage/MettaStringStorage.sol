// SPDX-License-Identifier: GNU GPLv3
pragma solidity =0.8.19;

import {IStringStorage} from "../interfaces/IStringStorage.sol";

contract MettaStringStorage is IStringStorage {
  // strings stored in separate variables instead of array
  // since solidity doesn't support constant string array variables
  string constant private _stringSlot0 = "{\"name\": \"Metta\",\"description\": \"DESCRIPTION:\n\"Metta\" is an exploration of the interconnected world, illustrated by Voronoi tessellations created with signed distance functions.\nThe patterns created in this project reflect life\'s intricate web, showing how individual entities, distinct yet interconnected, form a cohesive whole. The artwork\'s animation, driven by interaction between the entities, brings these connections to life, illustrating the dynamic nature of relationships.\nIn addition to the aesthetic display, the project is a metaphorical expression of the Metta philosophy. It invites viewers to contemplate the unseen connections in our lives and recognize the profound interconnectedness of all beings. \"Metta\" seeks to awaken a sense of unity and empathy in its mindful viewers, gently guiding them to appreciate the intricate web of relationships that form the fabric of our collective experience.\nCoded in vanilla JS with love, by Matto.\n\nINTERACTIVITY:\nBy default, \"Metta\" will draw itself in, slow down, and pause. This initial paused state creates the canonical image for the token. The paused state can be toggled by double-clicking on the canvas or by pressing the spacebar. \nHotkeys to interact with the script:\n- \" \" toggles pause\n- \"S\" saves a frame\n- \"<\" and \">\" change the background\'s brightness\nURL parameters to customize the experience:\n- portrait=true will run the script in a vertical aspect ratio (9x16)\n- continuous=true will bypass the initial automatic pausing mechanism\n- delay=<0-1000> will set the delay in milliseconds between draw cycles (default is 25)\",\"artistName\": \"Matto\",\"website\": \"https://matto.xyz/\",\"license\": \"CC BY-NC 4.0\",\"scriptLibrary\": \"na\",\"aspectRatio\": \"16:9\"}";

  string constant private _stringSlot1 = "const project = \"Metta\";console.log(`Metta v5.4.2 \\xa9 2023 Matto`),  console.log(    `TOKEN ID: ${artwork.tokenID}. TOKEN ENTROPY: ${artwork.seed}. TRAITS:`  ),  console.log(artwork.traits);let tokenEntropy = artwork.seed,  tokenEntropyPairs = createPairs(tokenEntropy),  seed =    getValue(0, 255) * getValue(0, 255) * getValue(0, 255) * getValue(0, 255),  R = (e = 1) => Math.floor(mRando() * e);function mRando(e = 1) {  return (    (bigSeed = BigInt(seed)),    (bigMult = BigInt(1664525)),    (bigSeed =      (bigSeed * bigMult + (bigNonce = BigInt(1013904223))) %      (bigMod = BigInt(4294967296))) <= Number.MAX_SAFE_INTEGER      ? (seed = Number(bigSeed))      : (console.log(\"Seed exceeded safe range, reseeding...\"),        (seed = Number(bigSeed % 999999999999))),    (seed / 4294967296) * e  );}const urlParams = new URLSearchParams(window.location.search),  portrait = urlParams.get(\"portrait\"),  delaySetting = urlParams.get(\"delay\"),  contSetting = urlParams.get(\"continuous\");let attributes = [],  p = [],  matte = 16,  hue,  width,  height,  canvas,  delayMS,  u,  rando,  nodes,  mode,  chaos,  freeze,  veiled,  cellDynamic,  connections,  thickness,  fade,  cellDesign,  colorMode,  gradientShift,  seekerNodeMod,  continuous = !1,  paused = !0,  count = 0,  lastTime = 0;function setup() {  \"true\" == portrait    ? (width = 0.5625 * (height = window.innerHeight)) > window.innerWidth &&      (height = (width = window.innerWidth) / 0.5625)    : (height = 0.5625 * (width = window.innerWidth)) > window.innerHeight &&      (width = (height = window.innerHeight) / 0.5625),    delaySetting && Number.isInteger(parseInt(delaySetting))      ? ((delayMS =          (delayMS = parseInt(delaySetting)) < 0            ? 0            : delayMS > 1e3            ? 1e3            : delayMS),        console.log(`Delay between cycles set to ${delayMS}ms.`))      : ((delayMS = 25),        console.log(          \"URL parameter for delay is not recognized, defaulting to 25ms.\"        )),    \"true\" == contSetting && ((continuous = !0), (paused = !1)),    ((canvas = document.createElement(\"canvas\")).width = width),    (canvas.height = height),    document.querySelector(\"body\").appendChild(canvas),    (ctx = canvas.getContext(\"2d\")),    (hue = 20 * getValue(1, 18)),    (rando = getValue(0, 255) * getValue(0, 255)),    (nodes = parseInt(artwork.traits.nodes, 10)),    (connections =      0 == (connections = getValue(0, 255) % 3)        ? 2        : 1 == connections        ? 4        : 10) > nodes && (connections = nodes - 1),    (thickness = getValue(0, 255) % 3),    (fade = (mode = parseInt(artwork.traits.mode, 10)) % 3 == 0),    (chaos = mode > 2),    (veiled = 2 == mode),    (cellDesign = parseInt(artwork.traits.cellDesign, 10)),    (colorMode = parseInt(artwork.traits.colorMode, 10)),    (cellDynamic = parseInt(artwork.traits.cellDynamic, 10)),    (gradientShift = getValue(0, 360)),    (freeze = 95),    (seekerNodeMod = !0 == chaos ? 1 : 5 == nodes ? 3 : Math.floor(nodes / 2)),    (u = ((thickness + 1) * (window.innerHeight + window.innerWidth)) / 2e3),    (ctx.fillStyle = \"hsl(0, 0%, 10%)\"),    ctx.fillRect(0, 0, canvas.width, canvas.height);  for (let e = 0; e < nodes; e++)    p.push({      x: R(1.5 * width) - width / 4,      y: R(1.5 * height) - height / 4,      r: 0,      c: [R(70) + 20, R(90) + 10],    }),      0 == e &&        (0 == colorMode ||          3 == colorMode ||          (console.log(\"(Primary Hue: \" + hue + \")\"),          2 == colorMode &&            console.log(\"(Secondary Hue: \" + ((hue + 180) % 360) + \")\")));}function draw(e) {  if (    e - lastTime >      (continuous        ? delayMS        : count < freeze        ? 1e3 / (freeze - count + 3)        : delayMS) &&    ((lastTime = e), !paused || count < freeze)  ) {    count++,      fade &&        ((ctx.fillStyle = \"hsla(0, 0%, 0%, 2%)\"),        ctx.fillRect(0, 0, canvas.width, canvas.height));    for (let t = 0; t < 1e3; t++) {      let o = R(width),        n = R(height),        l = width * height,        i,        a;      for (let s = 0; s < p.length; s++)        (a = Math.sqrt((o - p[s].x) ** 2 + (n - p[s].y) ** 2)) < l &&          ((l = a), (i = s));      ctx.lineWidth = 0.5 * u;      let r = hue,        $ = p[i].c[0];      0 == colorMode        ? ($ = 0)        : 2 == colorMode        ? i % 2 == 0 && (r = (hue + 180) % 360)        : 3 == colorMode &&          (r =            rando % 2 == 0              ? (p[i].x / width) * 360 + gradientShift              : (p[i].y / height) * 360 + gradientShift),        (ctx.strokeStyle = `hsl(${r}, ${$}%, ${p[i].c[1]}%)`),        (ctx.fillStyle = `hsl(${r}, ${$}%, ${p[i].c[1]}%)`);      let c = p[i].x - o,        d = p[i].y - n,        h = 20 * Math.sqrt(c * c + d * d),        y = p[i].x + 0.75 * (o - p[i].x),        g = p[i].y + 0.75 * (n - p[i].y),        _ = p[i].x + 1.1 * (o - p[i].x),        f = p[i].y + 1.1 * (n - p[i].y),        m = 1 == cellDesign ? h / 20 : 0 == cellDesign ? h / 30 : h / 40,        k = o + (-d / h) * m,        T = n + (c / h) * m,        S = o + (d / h) * m,        M = n + (-c / h) * m;      if (0 == cellDesign)        ctx.beginPath(),          ctx.moveTo(p[i].x, p[i].y),          0 == cellDynamic            ? ctx.lineTo(y, g)            : 1 == cellDynamic            ? ctx.lineTo(o, n)            : ctx.lineTo(_, f),          ctx.stroke(),          ctx.beginPath(),          ctx.moveTo(k, T),          ctx.lineTo(S, M),          ctx.stroke();      else if (1 == cellDesign) {        let v;        v = 0 == cellDynamic ? 0.75 * l : 1 == cellDynamic ? l : 1.25 * l;        let x = Math.atan2(T - p[i].y, k - p[i].x),          w = Math.atan2(M - p[i].y, S - p[i].x);        ctx.beginPath(), ctx.arc(p[i].x, p[i].y, v, x, w), ctx.stroke();      } else if (2 == cellDesign)        (ctx.fillStyle = `hsl(${r}, ${$}%, ${p[i].c[1]}%)`),          0 == cellDynamic            ? C(y, g, 1.5 * u)            : 1 == cellDynamic            ? C(o, n, 1.5 * u)            : C(_, f, 1.5 * u);      else if (3 == cellDesign) {        let D = 0 == cellDynamic ? 0.7 : 0.9;        cellDynamic < 2 &&          ((k = p[i].x + D * (k - p[i].x)),          (T = p[i].y + D * (T - p[i].y)),          (S = p[i].x + D * (S - p[i].x)),          (M = p[i].y + D * (M - p[i].y))),          ctx.beginPath(),          0 == cellDynamic            ? (ctx.moveTo(p[i].x, p[i].y),              ctx.lineTo(k, T),              ctx.lineTo(y, g),              ctx.lineTo(S, M))            : 1 == cellDynamic            ? (ctx.moveTo(p[i].x, p[i].y),              ctx.lineTo(k, T),              ctx.lineTo(o, n),              ctx.lineTo(S, M))            : (ctx.moveTo(y, g),              ctx.lineTo(k, T),              ctx.lineTo(_, f),              ctx.lineTo(S, M)),          ctx.closePath(),          ctx.stroke();      }      l > p[i].r &&        ((p[i].r = l),        (ctx.lineWidth = (50 / p[i].r) * 3 * u),        colorMode < 2 &&          (0 == colorMode            ? (ctx.strokeStyle = `hsl(0, 0%, ${p[i].c[1]}%)`)            : ((r = hue),              (ctx.strokeStyle = `hsl(${hue}, ${p[i].c[0]}%, ${p[i].c[1]}%)`)),          C(p[i].x, p[i].y, p[i].r, 0)));    }    moveTowardNClosest(connections);  }  requestAnimationFrame(draw);}function moveTowardNClosest(e) {  for (let t = 0; t < p.length; t++) {    let o = [];    for (let n = 0; n < p.length; n++)      if (t !== n) {        let l = Math.sqrt((p[t].x - p[n].x) ** 2 + (p[t].y - p[n].y) ** 2);        o.push({ dist: l, point: p[n] });      }    o.sort((e, t) => e.dist - t.dist);    let i = o[0].dist;    veiled || ((ctx.lineWidth = 0.5 * u), C(p[t].x, p[t].y, 2 * u));    for (let a = 0; a < e && a < o.length; a++) {      let s = u / (3 * Math.pow(1.5, a));      veiled ||        (ctx.beginPath(),        ctx.moveTo(p[t].x, p[t].y),        ctx.lineTo(o[a].point.x, o[a].point.y),        ctx.stroke(),        (ctx.lineWidth = s * u));      let r = 1 / (500 * Math.pow(2, a));      0 != t && t % seekerNodeMod == 0 && (r *= 10),        (p[t].x += (o[a].point.x - p[t].x) * r),        (p[t].y += (o[a].point.y - p[t].y) * r);    }    if (i <= 5) {      if (        ((p[t].x = R(1.5 * width) - width / 4),        (p[t].y = R(1.5 * height) - height / 4),        (p[t].r = 0),        0 == t)      ) {        let $ = rando % 2 == 0 ? hue - 10 : hue + 10;        $ < 0 ? ($ = 360 + $) : $ > 360 && ($ -= 360),          (hue = $),          console.log(\"(New hue: \" + hue + \")\");      }      p[t].c = [R(70) + 20, R(90) + 10];    }  }}function C(e, t, o, n) {  let l = 0 == n ? 100 : 60;  ctx.beginPath();  for (let i = 0; i < l; i++) {    let a = e + o * Math.cos((2 * Math.PI * i) / l),      s = t + o * Math.sin((2 * Math.PI * i) / l);    0 === i ? ctx.moveTo(a, s) : ctx.lineTo(a, s);  }  ctx.closePath(), 0 == n ? ctx.stroke() : ctx.fill();}function createPairs(e) {  let t = [];  for (let o = 0; o < (e.length - 2) / 2; o++)    t.push(parseInt(e.slice(2 + 2 * o, 4 + 2 * o), 16));  return t;}function getValue(e, t) {  if (0 === tokenEntropyPairs.length)    throw Error(\"No entropy values left in tokenEntropyPairs.\");  let o = Math.floor(tokenEntropyPairs[0] * ((t - e + 1) / 256) + e);  return tokenEntropyPairs.shift(), o;}function updateMatte() {  document.body.style.backgroundColor = `rgb(${16 * matte},${16 * matte},${    16 * matte  })`;}setup(),  requestAnimationFrame(draw),  canvas.addEventListener(\"dblclick\", function (e) {    console.log(\"Canvas double-clicked:\", e), (paused = !paused);  }),  document.addEventListener(\"keydown\", function (e) {    if (\" \" === e.key) paused = !paused;    else if (\"s\" === e.key || \"S\" === e.key) {      let t = document.createElement(\"a\");      (t.download = `Metta-${artwork.tokenID}.png`),        (t.href = canvas.toDataURL()),        t.click();    } else      \"<\" === e.key        ? (0 != matte ? matte-- : (matte = 16), updateMatte())        : \">\" === e.key && (16 != matte ? matte++ : (matte = 0), updateMatte());  });";

  /** @inheritdoc IStringStorage*/
  function stringAtSlot(uint8 _slot) external pure returns (string memory) {
    if (_slot == 0) return _stringSlot0;
    if (_slot == 1) return _stringSlot1;
    revert EmptySlot();
  }
}